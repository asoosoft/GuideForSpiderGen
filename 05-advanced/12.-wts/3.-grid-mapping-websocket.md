---
description: RestAPI 외에 WebSocket 방식으로 종목 데이터 받는 예제.
---

# 3. 종목 - Grid Mapping (WebSocket)

RestAPI 는 1회성 요청에 대한 응답을 받는것으로 끝나지만, 각 종목들의 가격은 실시간으로 변하기때문에 변하는 값을 주기적으로 업데이트가 되어야 할 필요가 있다.&#x20;

이런경우 WebSocket 으로 연결이 유지되는 상태에서 종목 데이터를   실시간 처리가 필요하다.==

### 1. 프로젝트 준비

&#x20;앞의 예제 프로젝트에서 계속 진행합니다. [2.-grid-mapping-restapi.md](2.-grid-mapping-restapi.md "mention")

앞에서 받은 종목들의 가격변화를 매번 업데이트를 진행해봅니다.



### 2. 실시간 업데이트 모듈 생성 (RealQueryManager.js)

Library 폴더에 RealQueryManager.js 를 추가합니다.

기능: 거래소에지속적인 데이터 요청및 Component Update

code:

```javascript

class RealQueryManager extends QueryManager
{
    constructor(name, eventHandler)
    {
        super(name)

        this.eventHandler = eventHandler;

        this.addQueryListener(this);
        this.textDecoder = new TextDecoder();
    }

    onReceived(data)
    {
        let msg = this.textDecoder.decode(new Uint8Array(data));
        let cloneMsg = JSON.parse(msg);
        msg = JSON.parse(msg);

        if(msg.error) {
            console.error(msg.error);
            return;
        }

        if(msg.st == 'SNAPSHOT') this.queryProcess({body:{OutBlock1:[msg]}});
        else this.realProcess(msg);
    }

    //	onReceive 함수 내에서 패킷 타입에 따라 분기하여 호출되는 함수
    async realProcess(recvObj)
    {
        if(recvObj.error)
        {
            console.error(recvObj.error);
            return;
        }

        var qryName = recvObj.ty,
            aquery = await AQuery.getSafeQuery(qryName), 
            queryData = null;
        
        queryData = this.makeQueryData(aquery);

        for(let key in recvObj) {
            if(Array.isArray(recvObj[key])) {
                recvObj[key].forEach((data, i) => {
                    for(let field in data) {
                        recvObj[`${field}${i}`] = data[field];
                    }
                })
                delete recvObj[key];
            }
        }

        if(recvObj[""]) debugger;

        queryData.outBlockData({body:{OutBlock1:[recvObj]}});
        this.realDataToComp(recvObj.cd, queryData);
        
        if(recvObj[""]) debugger;
    }

    onConnected(success)
    {
        this.eventHandler.onConnected(success);
    }

    onClosed()
    {
        this.eventHandler.onClosed();
    }

    /**
     * 업비트 리얼데이터는 등록,해제 방식이 아님.
     * 리얼 요청 앞뒤로 티켓필드와 포맷필드가 필요.
     * [{Ticket Field},{Type Field},....,{Type Field},{Format Field}]
     * 
     * 요청을 보내면 이전에 요청중이던 모든것이 날라가버리므로
     * 기존에 요청했던 항목들을 가지고 있다가 갱신해줘야한다.
     * 
     * 참고로 모두다 해제는 Type Field가 없으면 된다.
     * [{Ticket Field},{Format Field}]
     */

    async registerReal()
    {
        await super.registerReal.apply(this, arguments);
    }

    sendRealSet(aquery, isSet, regArr)
    {
        const qryName = aquery.getName();
        const sendArr = [];
        sendArr.push(this.getTicket());
        
        if(isSet)
        {
            if(!this.realTypeMap[qryName]) this.realTypeMap[qryName] = [];

            regArr.forEach(item => {
                if(!this.realTypeMap[qryName].includes(item)) {
                    this.realTypeMap[qryName].push(item);
                }
            });
        }
        else
        {
            this.realTypeMap[qryName] = this.realTypeMap[qryName].filter(item => !regArr.includes(item));
            //일단 해제는 전송은 안함. 등록할때 갱신됨 어차피 
            return;
        }

        const typeArr = this.makeRealType();
        if(typeArr.length > 0) sendArr.push(...this.makeRealType());
        sendArr.push({ "format": "SIMPLE" });

        console.log(sendArr);
        this.sendBufferData(JSON.stringify(sendArr));
    }

    makeTicket()
    {
        this.ticket = 'spider_'+new Date().getTime();
        this.realTypeMap = {};
    }

    makeRealType()
    {
        const arr = [];

        for(let qryName in this.realTypeMap)
        {
            if(!this.realTypeMap[qryName] || this.realTypeMap[qryName].length == 0) continue;
            arr.push({
                "type" : qryName,
                "codes" : this.realTypeMap[qryName],
                "isOnlyRealtime" : true
            });
        }

        return arr;
    }

    getTicket()
    {
        if(!this.ticket) this.makeTicket();

        //return {"ticket":this.ticket}
        return {"ticket":this.ticket+'_'+ this.makePacketId()}
    }

    sendByType(obj)
    {
        this.sendBufferData(JSON.stringify(obj.sendObj.sendArr));
    }
}


```



### 3. Query 파일 추가

rest\_ticker.qry

* DataGrid 에 전체  종목의 값을 채우기 위한 Query&#x20;

```json
{
	"desc": "현재가",
	"queryType": "쿼리 타입",
	"name": "rest_ticker",
	"url": "ticker",
	"input": {
		"InBlock1": {
			"format": [
				["market 코드","markets","","","char",1,0]
			]
		}
	},
	"output": {
		"OutBlock1": {
			"format": [
				["종목 구분 코드","market","","","char",9,0],
				["현재가","trade_price","","","char",0,0],
				["전일 대비EVEN보합RISE상승FALL하락","change","","","char",0,0],
				["변화율의 절대값","change_rate","","","char",0,0]
			]
		}
	}
}
```

ticker.qry

* 종목별 업데이트되는 값들을 적용하기 위한 Query

```json
{
	"desc": "현재가",
	"queryType": "쿼리 타입",
	"name": "ticker",
	"input": {
		"InBlock1": {
			"format": [
				["market 코드","codes","","","char",1,0]
			]
		}
	},
	"output": {
		"OutBlock1": {
			"format": [
				["시장코드","market","","","char",9,0],
				["마켓 코드","cd","","","char",0,0],
				["현재가","tp","","","char",0,0],
				["전일 대비 값","scp","","","char",0,0],
				["24시간 누적 거래대금","atp24h","","","char",0,0]
			]
		}
	}
}
```

### 4. Query Mapping (MainView.lay)

기존에 rest\_market.qry 에 mapping 되어있던 ADataGrid 를 다시 mapping 합니다.

ADataGrid 는 여러 쿼리를 한 DataGrid 에 mapping 하여 사용가능합니다.



* Query 옆 제거 버튼으로 기존 연결된 Query 제거

<figure><img src="../../.gitbook/assets/image (6) (1) (1).png" alt=""><figcaption></figcaption></figure>

* rest\_ticker  mapping&#x20;

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* ticker mapping

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### 5. 코드 적용 (MainView.js)

초기화

Code:

```javascript

onInitDone()
{
	super.onInitDone()

	this.qmRest = new RestQueryManager('REST');
	this.qmRest.setNetworkIo(new UbHttpIO(this.qmRest));	
	this.qmRest.setTimeout(Define.TIMEOUT_SEC);
	
	this.qmReal = new RealQueryManager('REAL', this);
	this.nio = new WebsocketIO(this.qmReal, true);
	this.qmReal.setNetworkIo(this.nio);
}
```

* 기존 rest 요청외에 실시간 요청을 위한 RealQueryManager 초기화 추가.



연결버튼 이벤트  처리

Code:

```javascript
onConnectBtnClick(comp, info, e)
{
	this.qmRest.startManager(Define.SERVER_ADDR_REST);
        this.qmReal.startManager(Define.SERVER_ADDR_WEBSOCKET);
}
```

* 각 QueryManager 로 거래소 연결



접속후 처리

Code:

```javascript
onConnected(success)
{
    if(success)
    {
        this.requestMarketData();
    }
}

// 종목 데이터 요청
requestMarketData()
{
    this.dataGrid.setRealMap('cd');

    const containerId = this.getContainerId();
    this.qmRest.sendProcessByName('rest_market',containerId , null, queryData=>{
        queryData.getBlockData('InBlock1')[0].is_details = true;
    }, queryData=>{
        const outBlock = queryData.getBlockData('OutBlock1');

         const marketNamesArr = Object.values(outBlock).map(item=>item.market);

         this.requestTickData(marketNamesArr, containerId);
    });
}

// 종목의 tick data 요청
requestTickData(marketArr , containerId)
{
    // dataGrid 는 tick data 를 요청하기전에 한번 전체데이터를 요청해서 설정해야 함.
    this.qmRest.sendProcessByName('rest_ticker', containerId, null, queryData=>{
        const block = queryData.getBlockData('InBlock1')[0];
        block.markets = marketArr;
    }, queryData=>
    {
        const outBlock = queryData.getBlockData('OutBlock1');
        outBlock.forEach(item=>{
             item.cd = item.market
        });

        this.qmReal.registerReal('ticker', 'cd', marketArr, [this.dataGrid], 0);
    });
}
```

* restQueryManager 로부터 종목데이터 전체 요청 및 종목 가격 데이터 요청
* realQueryManager 로부터 종목별 변경된 가격 요청

### 6. 결과 확인

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* 현재가와 거래대금 가격이 변하지 확인합니다.



### 7. 숫자 표현 개선

각 Cell 에 부호및   자리수를 표시하기 위해서는 , 코드 외에도 DataMask 를 사용하는방법이 있습니다.

Grid 에 Data Property 선택

<figure><img src="../../.gitbook/assets/image (7) (1).png" alt=""><figcaption></figcaption></figure>



현재가 Cell 에서add 버튼 클릭 한후  function 선택.

<figure><img src="../../.gitbook/assets/image (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* Numer.money 추가 -> Cell 이 숫자인경우 금액에 Comma 로 자리수  표현
* Text.suffix 추가 ("원", "") -> Cell 의 숫자 뒤에 금액 추가



전일대비 Cell

<figure><img src="../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

* Number.percent 추가 ->  숫자 뒤에 % 를 추가



거래대금 Cell

<figure><img src="../../.gitbook/assets/image (4) (1) (1).png" alt=""><figcaption></figcaption></figure>

* Number.divide("1000000", "1") -> 백만단위로 나누고 정수만 표현
* Number.money-> 자리수표현
* Text.suffix ("백만", "") -> 위에서 백만단위로 나눈 결과값의 뒤에 '백만' 부호 추가.

\*\*\*\*\*\* 중요 : 처리가  위로부터 진행이 되니 , 숫자 연산작업을 제일 위로 올려서 진행해야 오류가 발생하지 않음.



### 7. 결과 재확인

<figure><img src="../../.gitbook/assets/image (5) (1) (1).png" alt=""><figcaption></figcaption></figure>

각 Cell 의 수치에 부호가 잘 처리되었는지 확인합니다.



### 8. 비주얼 개선

DataGrid  의 값이 변하면 좀더 확실히 볼수 있게 비주얼 처리를 추가합니다.

* Library 폴더에 Format 을 추가합니다

<figure><img src="../../.gitbook/assets/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

fmt 파일에 아래와 같은 코드를 추가합니다 (CellUpdate.fmt)

```javascript
/*
* ADataMask 사용자 정의 파일
*/
if(!ADataMask.CellUpdate) ADataMask.CellUpdate = {};
ADataMask.CellUpdate.funcName =
{
	title : "함수 설명",
	param : ["파라미터1 설명", "파라미터2 설명"], //마스크 등록 시 입력할 파라미터 정의
	func : function funcName(value, param, ele, dataObj)
	{
        const [data , keyArr, queryData] = ADataMask.getQueryData();

        // 실시간 업데이트로 받은 데이터인지 여부
        if(queryData?.isReal)
        {
            dataObj.style = 'border: 2px solid red';

            setTimeout(()=>{
                dataObj.style = '';
            }, 500)
        }

		return value;
	}
};

```

CellUPdate 파일을  적용하기위해 DataGrid 의 DataProperties 를 선택합니다

<figure><img src="../../.gitbook/assets/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

두번째 Cell 을 선택후 방금 생성한 Cellupdate 을 적용합니다.

<figure><img src="../../.gitbook/assets/image (7) (1) (1).png" alt=""><figcaption></figcaption></figure>

* 두번째 Cell 선택(다른 Cell 선택해도 무방)
* 오른쪽 Mask 에 add 버튼 클릭
* Type 에 방금 생성한 CellUpdate 선택



### 9. 결과 재확인

<figure><img src="../../.gitbook/assets/image (8) (1).png" alt=""><figcaption></figcaption></figure>

특정 종목의 값이 Update 될때 외곽선이 출력되는지 확인합니다.



Download

{% file src="../../.gitbook/assets/SpiderGPT.zip" %}

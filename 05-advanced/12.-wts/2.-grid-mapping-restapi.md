---
description: 거래소로부터 받은 종록들의 정보를 Grid 에 Mapping 된 정보를 통해 표현
---

# 2. 종목 - Grid Mapping (RestAPI)

Grid 에 값을 입력하는 방법은 2가지가 있습니다.

* Grid 의 열과 행에 코드로 데이터 추가.&#x20;
* Grid 에 데이터를 mapping 하여 자동화

거래소의 정보를 Grid Mapping 방식으로 표현하여 CodeBase 기반보다 간결함을 보여주는 에제입니다.

### 1. 모듈 추가 및 초기 로딩 모듈 선택

* sys Framework 추가
* Default Laod Setting  체크
  *

      <figure><img src="../../.gitbook/assets/image (184).png" alt="마우스 오른 클릭"><figcaption><p>&#x3C;각 항목선택 후 마우스 오른 클릭></p></figcaption></figure>
  * afc&#x20;
    * ADatamak.js
    * DnDManager.js
    * AIndicator.js
  * sys&#x20;
    * AQuery.js
    * AQueryData.js&#x20;
    * QueryManager.js
    * HttpIO.js
    * NetworkIO.js
    * QueryManager.js
    * WebSocketIO.js



### 2.  거래소 통신 모듈 생성 (UpbitHttpIO.js)

Library 폴더에 UpbitHttpIO.js 를 추가합니다.

Code:

```javascript
class UbHttpIO extends HttpIO
{
	constructor(listener)
	{
		super(listener)		
	}

    //업비트 API호출이라 업비트 WAS에서 분배되어야할 내용을 이곳에서 처리함.
    //공통으로 처리하기 애매하기때문에 SWITCH문으로 분배함.
	sendData(data, callback)
	{
        const packetId = data.header.packetId;

        const apiUrl = this.makeAPIUrl(data);

        if(!apiUrl)
        {
            this.onError(packetId, new Error('Can not make api'));
            return;
        }
        
        console.log(apiUrl)
		fetch(apiUrl).then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        }).then(data => {
			this.listener.packetInfo.packetId = packetId;
            this.onReceived(data, data.length);
        }).catch(error => {
            //this.onError(packetId, error);
            console.error('api error', error);
        });
    }

    //일단 사용자 input값은 inblock1[0]에 있음 무조건 다른 경우는 없음.
    makeAPIUrl(data)
    {
        const block = data.body.InBlock1[0];

        let url = this.url;
        url += data.header.url;
        
        let paramStr = '';
        if(block) {
            paramStr = '?';
            for(let key in block) {
                if(block[key]) {
                    if(paramStr.length > 1) paramStr += '&';
                    paramStr += `${key}=${block[key]}`;
                }
            }

            url += paramStr;
        }
        return url;
    }
	
    onReceived(result, packetId, isToSignal)
    {
	if(this.listener) this.listener.onReceived(result, packetId, isToSignal)
    }
	
    onError(packetId, errorObj, isToSignal)
    {
	if(this.listener.onError) this.listener.onError(packetId, errorObj, isToSignal);
    }
}

```

기능:&#x20;

* 거래소 연결
* API 통신요청및 결과 수신.



### 3. QueryManager 생성

* RestQueryManager.js 추가
  * Libaray 폴더에 RestQueryManager.js 를 추가합니다.

Code:

```javascript
class RestQueryManager extends QueryManager
{
	constructor(name)
	{
		super(name)

		this.addQueryListener(this);
	}

	onReceived(dataArr, dataLen)
	{
        //check
        let arrKeyArr = [];
        for(let key in dataArr[0]) {
            if(Array.isArray(dataArr[0][key])) {
                arrKeyArr.push(key);
            }
        }
        if(arrKeyArr.length) {
            dataArr.forEach(data => {
                arrKeyArr.forEach(key => {
                    data[key].forEach((d, i) => {
                        for(let field in d) {
                            data[`${field}${i+1}`] = d[field];
                        }
                    })
                    delete data[key];
                });
            })
        }

		this.queryProcess({body: {OutBlock1: dataArr}});
	}

	//특이사항(서버변경불가이슈)
	//실제로 서버에 보낼때는 헤더에 들어가는 정보중 몇가지(연속키 cont_key 등)는
	//헤더에 안들어가고 body.option에 들어가야함. 혼동이 있을수있어서 화면 개발자들은 
	//모두 헤더에 넣도록 하고 옵션으로 변환시킴
	makeHeader(queryData, sendObj, menuNo)
	{
		const packetId = this.makePacketId();
		const tr_name = queryData.getQueryName();
        const contKey = queryData.getContiKey();
		 //헤더 세팅
		sendObj.header = 
		{
			...this.headerInfo,
			...queryData.headerInfo,
            tr_name : tr_name,
            packetId : packetId,
            contKey: contKey,
            url: queryData.getQuery().getValue('url')
		};
		
		return packetId;
	}
	
	sendByType(obj)
	{
        //JSON.stringify 한 데이터를 전달하지 않게 수정
		this.sendBufferData(obj.sendObj);
	}

	//에러세팅
	setErrorData(recvObj)
	{
		this.errorData.errCode = recvObj.code;
		this.errorData.errMsg = recvObj.message;
	}

	//정상적인 에러코드가 아닌 통신 장애
	onError(packetId, errorObj)
	{
		console.log(errorObj.code +', '+errorObj.error);
	}
}
```

기능:&#x20;

* Rest API 로 거래소와 통신.
* 요청을 Query 에서 InBlock 에 정의된 값으로부터 생성하여 전송.
* 결과값을 Query 에서  정의된 데이터만 OutBlock 으로 생성.
* DataMapping 된 Component 에 값 전달.

### 4. Query 생성

* ADataGrid 와 Mapping 할 Query 를 생성합니다.
* Query 폴더 메뉴에서 QueryMaker 실행
  *

      <figure><img src="../../.gitbook/assets/image (9) (1) (1) (1) (1).png" alt=""><figcaption><p>&#x3C;Queyr 폴더 선택후 마우스 오른 클릭></p></figcaption></figure>
*   \+ 버튼으로 Query 추가한후 InBlock 과 OutBlock 값 입력

    * name: rest\_market

    <figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>



    * 혹은  Query 파일생성후 아래의 코드로 덮어쓰기
    *   rest\_market.qry

        ```json
        {	
        	"desc": "종목코드조회",
        	"queryType": "쿼리 타입",
        	"name": "rest_market",
        	"url": "market/all",
        	"input": {
        		"InBlock1": {
        			"format": [
        				["상세 정보 노출 여부","is_details","","","char",1,0]
        			]
        		}
        	},
        	"output": {
        		"OutBlock1": {
        			"format": [
        				["시장 정보","market","","","char",9,0],
        				["한글명","korean_name","","","char",8,0],
        				["영문명","english_name","","","char",6,0],
        				["유의종목 지정 여부","warning","","","char",6,0],
        				["주의종목 지정 여부","caution","","","char",6,0]
        			]
        		}
        	}
        }
        ```



### 5. 화면생성 및 Data Mapping (MainView.lay)

* ADataGrid 와 Button 을 배치 (데이터 출력과 거래소 연결 버튼)

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

* Button 의 ID 를 connectBtn 으로 생성후 클릭이벤트 추가&#x20;

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

* Query Mapping
  * ADataGrid 선택후 DataProperties 선택
    *

        <figure><img src="../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>


  * 열린창에서 DataGrid 의 Colulm 갯수가 5개가 아니면 추가한후 Header 이름도 적절히 변경합니다.
    * 시장정보, 한글명, 영문명, 유의종목지정여부, 주의종목 지졍여부
    *   입력완료후확인을 눌러 창을 닫습니다.

        <figure><img src="../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>
  * ADataGrid 선택후 DataQuery 선택
    *

        <figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>



        * 좌측 에서 rest\_market 을 선택하여 ADataGrid 와 연결시킨후, 하단의 OutBlock 요소들을 선택하여 각  Cell 과 Query Mapping 진행.
          *

              <figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

### 6. 코드작업 (MainView.js)

* 초기화&#x20;
  * 거래소 연결에 필요한 각종 인스턴스 초기화

```
onInitDone()
{
	super.onInitDone()

	this.qmRest = new RestQueryManager('REST');
	this.qmRest.setNetworkIo(new UbHttpIO(this.qmRest));
	this.qmRest.startManager(Define.SERVER_ADDR_REST);
	this.qmRest.setTimeout(Define.TIMEOUT_SEC);
	this.nio = new WebsocketIO(this, true);
}
```



* 버튼클릭 이벤트 연결&#x20;
  * 클릭시 거래소 정보를 요청하고, rest\_makret 의 inblock 값으로  파라미터를 전송
  * 응답이 오면 ADataGrid 에 Mapping된 정보대로 데이터 추가

```
onConnectBtnClick(comp, info, e)
{
    this.nio.startIO(Define.SERVER_ADDR_WEBSOCKET);        
}

onConnected(success)
{
    if(success)
    {
        this.nio.setHeartbeat(null);

        const asyncFunc = async()=> { await this.requestMarketDataAsync() };
        asyncFunc();
    }
}

async requestMarketDataAsync()
{
    const containerId = this.getContainerId();
    this.qmRest.sendProcessByName('rest_market',containerId , null, queryData=>{
        queryData.getBlockData('InBlock1')[0].is_details = true;
    });
}
```





### 5. 결과 확인

<figure><img src="../../.gitbook/assets/image (5) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* Mapping 된정보대로 데이터가 입력되었는지 확인.



Project Download&#x20;

{% file src="../../.gitbook/assets/WTS_Sample (1).zip" %}

